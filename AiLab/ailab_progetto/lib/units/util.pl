:- module(util, [
	      context_var/2,
	      mem_var/2,
	      distinct_vars/1,
	      ground_vars/2
		]).

unit(util,[]).
:- discontiguous([ pred/1, import_type/2, local_pred/1]).

import_type(units, [typed_var/0,
		   is_type/0,
		   pattern/0
		  ]).

pred(context_var(var, list(typed_var))).
%  context_var(?X, +C):  X is a variable of context C
context_var(X,[V:_|L]) :-
	X==V,!
	;
	context_var(X,L).

pred(mem_var(var, list(var))).
%  mem_var(?X, +L):   X is a variable of L
mem_var(X,[V|L]) :-
	X==V,!
	;
	mem_var(X,L).

pred(distinct_vars(list(var))).
%  distinct_vars(+L):  L is a list of distinct vars
distinct_vars(V) :-
	distinct_vars(V,[]).

local_pred(distinct_vars(list(var), list(var))).
distinct_vars([],_).
distinct_vars([X|V],V1) :-
	not(mem_var(X,V1)),
	distinct_vars(V,[X|V1]).

pred(ground_vars(atom, any)).
%  ground_vars(+N, @Term):
%  side-effect:  Term is grounded by substituting each variable
%  with a new name N_k:  e.g.
%  ?- Term = f(A,B), ground_vars(x, Term).
%  A=x1
%  B=x2
%  Term=f(x1,x2)
%
ground_vars(Name, A) :-
	term_variables(A, Vars),
	reset_gensym(Name),
	maplist(to_g(Name), Vars).

local_pred(to_g(atom, var)).
% to_g(+N, @X)  substitutes X by Nk,
% k generated by gensym
to_g(Name, X) :-
	gensym(Name, V),
	X=V.


